# i18n 実装ガイドライン

## 1. 基本実装方針

私たちのi18n実装は、シンプルさと型安全性を重視しています。実装の中核は `src/i18n/text.ts` にあり、以下の特徴があります：

```typescript
// 言語ごとのメッセージを集約
const locales = { en: { common: common_en }, ja: { common: common_ja } };

// 型安全な翻訳関数
export const text = (locale: keyof typeof locales) => locales[locale];

// React Hooks用のユーティリティ
export const useText = () => ({ t: text("ja") });
```

### 特徴

- TypeScriptの型システムを活用し、翻訳キーの補完と型チェックを実現
- 言語ファイルの分割管理による保守性の向上
- シンプルなAPI設計による学習コストの低減

## 2. コンポーネントでの使用方法

tree-container.tsxの実装を参考に、以下のようにコンポーネントで使用します：

```typescript
// フックのインポート
import { useText } from "~/i18n/text";

export function YourComponent() {
  // t オブジェクトの取得
  const { t } = useText();

  return (
    <div>
      {/* ネストされたキーへのアクセス */}
      <h1>{t.common.navigation.home}</h1>

      {/* 動的な翻訳の使用 */}
      <p>{t.common.bookmarks.validation.maxDepth(5)}</p>

      {/* エラーメッセージなどの共通テキスト */}
      <div>{t.common.errors.general}</div>
    </div>
  );
}
```

### ベストプラクティス

- useTextフックは、翻訳が必要なコンポーネントのトップレベルで呼び出す
- 頻繁に使用する翻訳キーは、分割代入で取り出して使用する
- パフォーマンスのため、メモ化が必要な場合はuseMemoと組み合わせる

## 3. メモリ効率を考慮した翻訳データの管理

### 構造化されたデータ管理

```typescript
export const common = {
  navigation: {
    home: "ホーム",
    bookmarks: "ブックマーク",
  },
  actions: {
    add: "追加",
    edit: "編集",
  },
} as const;
```

### 効率化のポイント

1. **階層構造の活用**

   - 関連する翻訳をカテゴリごとにグループ化
   - 深すぎない階層（最大3階層程度）を維持

2. **型の最適化**

   - `as const`アサーションによる厳密な型定義
   - 共通の型定義による一貫性の確保

3. **動的な翻訳の効率化**
   - パラメータ化された翻訳は関数として実装
   - 必要な場合のみ動的な値を生成

## 4. 新しい言語やテキストの追加

### ファイル構成

```
src/i18n/
├── locales/
│   ├── en/
│   │   ├── common.ts      # 共通の翻訳
│   │   ├── bookmarks.ts   # ブックマーク機能の翻訳
│   │   ├── settings.ts    # 設定画面の翻訳
│   │   └── errors.ts      # エラーメッセージの翻訳
│   └── ja/
│       ├── common.ts
│       ├── bookmarks.ts
│       ├── settings.ts
│       └── errors.ts
└── text.ts
```

### 新しい言語の追加手順

1. `src/i18n/locales/[言語コード]/`ディレクトリを作成
2. 機能ごとに以下の翻訳ファイルを作成：
   - `common.ts`: 共通のUIテキスト
   - 機能固有のファイル（例：`bookmarks.ts`）
   - `errors.ts`: エラーメッセージ
3. 各ファイルは既存の言語ファイルの構造を踏襲
4. `text.ts`にインポートと型定義を追加

### ファイル分割のメリット

- 機能ごとの責任の明確化
- チーム開発での作業の並列化が容易
- 必要な翻訳のみを読み込むことによるパフォーマンス最適化
- メンテナンス性の向上

### 新しいテキストの追加手順

1. 適切な機能のファイルを選択（または新規作成）
2. まず日本語（ja）のファイルに新しいキーと翻訳を追加
3. 適切なカテゴリの下に配置（必要に応じて新しいカテゴリを作成）
4. 他の言語の同じファイルに同じキーを追加
5. TypeScriptの型チェックを使用して、全言語で必要なキーが実装されていることを確認

### 命名規則

- キー: キャメルケース（例：`newFolder`, `importSuccess`）
- カテゴリ: 名詞の単数形（例：`navigation`, `action`）
- 動的パラメータ: 明確な型定義（例：`maxDepth: (depth: number) => string`）
- ファイル名: 機能名を小文字で（例：`bookmarks.ts`, `settings.ts`）

## 5. 新機能実装時の多言語対応プロセス

新しい機能やコンポーネントを追加する際は、以下のプロセスを必ず実施してください：

### 実装前の準備

1. 本ガイドラインを参照し、i18n実装の基本方針を理解する
2. 新機能で必要となる翻訳キーを洗い出し、適切な階層構造を設計する
3. 必要に応じて新しい翻訳ファイルの作成を検討する

### 実装時のチェックリスト

- [ ] i18n用の翻訳キーを適切な階層構造で追加
- [ ] 日本語（ja）の翻訳データを登録
- [ ] 英語（en）の翻訳データを登録
- [ ] コンポーネント内で文字列をハードコーディングしていないことを確認
- [ ] 各言語で翻訳キーが正しく表示されることを確認
- [ ] 動的な翻訳（パラメータを含む翻訳）のテスト
- [ ] エラーメッセージやバリデーションメッセージの確認

### 実装後の確認事項

1. 全ての文字列が翻訳キーを通して表示されていることを確認
2. 各言語でUIレイアウトが崩れていないことを確認
3. 新規追加した翻訳キーをドキュメントに反映
4. 翻訳データの型チェックエラーがないことを確認

## 実装時の注意点

1. **型安全性の維持**

   - 全ての言語ファイルで同じ構造を保持
   - 未定義のキーへのアクセスは型エラーとして検出

2. **パフォーマンスの考慮**

   - 大きな翻訳ファイルは機能ごとに分割
   - 動的な翻訳生成は最小限に抑える
   - 必要な翻訳のみを読み込む（遅延ロード検討）

3. **保守性の向上**

   - 意味のある命名でキーを作成
   - コメントで特殊なケースを説明
   - 非推奨になったキーは段階的に削除
   - 機能の追加・削除に応じて翻訳ファイルも整理

4. **既存コードとの整合性**
   - コンポーネント内で一貫した翻訳キーの使用
   - UI/UXの一貫性を保つための共通テキストの活用
   - 機能固有の翻訳は対応するファイルに配置

## 今後の展開

1. **自動検証の導入**

   - 未使用の翻訳キーの検出
   - 欠落している翻訳の自動チェック
   - 翻訳の一貫性チェック
   - 機能ごとの翻訳カバレッジ確認

2. **開発者エクスペリエンスの向上**
   - VSCode拡張機能による翻訳補完
   - 翻訳管理ツールの導入検討
   - 自動翻訳APIの活用検討
   - 翻訳ファイルの自動生成スクリプト
