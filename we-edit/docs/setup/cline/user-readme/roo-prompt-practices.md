# Roo特化型プロンプトエンジニアリングのベストプラクティス

## 1. モード活用の最適化

Roo を最大限に活用するためには、タスクの種類に応じて適切なモードを選択し、各モードの特性を理解することが重要です。

### 1.1 適切なモードの選択

各モードには、特定のタスクに特化した機能と役割が割り当てられています。

*   **Code Mode**: コーディングや実装タスクに最適です。コードの記述、修正、リファクタリングなど、コードに関する作業を行う際に使用します。
    ```markdown
    例 1: "TypeScript で、React のカスタムフックを実装して、指定された API からデータを取得し、エラーハンドリングを行うようにしてください。"
    例 2: "この JavaScript コードを読み込み、バグを修正してください。"
    例 3: "この Python 関数をリファクタリングして、より効率的なコードにしてください。"
    ```

*   **Architect Mode**: プロジェクトの設計や構造化に関するタスクに最適です。システムのアーキテクチャ、ディレクトリ構造、モジュール間の依存関係などを検討する際に使用します。
    ```markdown
    例 1: "このプロジェクトの現在のディレクトリ構造を分析し、React コンポーネントの再利用性を高めるために、どのように構造を見直すべきか提案してください。"
    例 2: "このシステムのデータベース設計を見直し、スケーラビリティを向上させるための提案をしてください。"
    例 3: "このマイクロサービスのアーキテクチャを評価し、改善点を見つけてください。"
    ```

*   **Ask Mode**: 質問や情報収集に最適です。技術的な疑問、API の使い方、ライブラリの機能など、様々な情報を収集する際に使用します。
    ```markdown
    例 1: "React の最新バージョンの機能について、特にパフォーマンス向上に貢献する機能について教えてください。"
    例 2: "AWS Lambda の設定方法について、詳細な手順を教えてください。"
    例 3: "このライブラリの API ドキュメントへのリンクを教えてください。"
    ```

*   **Debug Mode**: 問題解決やデバッグに最適です。エラーメッセージの原因特定、コードの修正、テストの実行など、問題解決に関する作業を行う際に使用します。
    ```markdown
    例 1: "このエラーメッセージ「TypeError: Cannot read properties of undefined (reading 'map')」の原因を特定し、修正するためのコードを提案してください。"
    例 2: "このテストケースが失敗している原因を特定し、修正してください。"
    例 3: "このコードのパフォーマンスボトルネックを特定し、改善策を提案してください。"
    ```

### 1.2 モード切り替えの最適化

タスクによっては、複数のモードを組み合わせて使用することが効果的です。

*   タスクの性質に応じて、適切なモードを選択します。
*   複合的なタスクは、段階的にモードを切り替えることで、より効率的に実行できます。
    *   例: まず Architect Mode で設計を行い、Code Mode で実装を行う。
*   各モードの特性を活かした指示の出し方を意識します。
    *   例: Architect Mode では、抽象的な指示や設計に関する質問を行い、Code Mode では、具体的なコードの記述や修正を指示する。
*   モードを切り替える際には、コンテキストを適切に引き継ぐように指示します。
    *   例: "Architect Mode で設計した内容に基づいて、Code Mode で React コンポーネントを実装してください。"

## 2. ツール活用の最適化

Roo は、様々なツールを提供しており、これらのツールを効果的に活用することで、タスクの効率性と精度を向上させることができます。

### 2.1 ファイル操作系ツール

*   **read_file**: 既存のコードや設定ファイルの内容を分析する際に使用します。
    ```markdown
    - 大規模なファイルは避け、必要な部分のみを読み込むように指示します。
    - コンテキストを理解するために、段階的にファイルを読み込むように指示します。
    - ファイルの特定の行やセクションのみを読み込むように指示することもできます。
    ```
    ```markdown
    例 1: "src/components/Button.tsx ファイルのコードを読み込み、Button コンポーネントの props の型定義を確認してください。"
    例 2: "src/config/app.json ファイルの `apiEndpoint` の値を読み込んでください。"
    例 3: "src/App.js ファイルの 10 行目から 20 行目のコードを読み込んでください。"
    ```

*   **write_to_file**: 新しいファイルを作成したり、既存のファイルを完全に書き換える際に使用します。
    ```markdown
    - ファイルの完全な内容を一度に提供するように指示します。
    - 行数を正確にカウントするように指示します。
    - ファイルのエンコーディングを指定することもできます。
    ```
    ```markdown
    例 1: "src/utils/api.ts ファイルを作成し、指定された API エンドポイントからデータを取得する関数を実装してください。ファイルの内容は以下の通りです。"
    例 2: "package.json ファイルを書き換え、新しい依存関係を追加してください。ファイルの内容は以下の通りです。"
    例 3: "index.html ファイルを UTF-8 エンコーディングで作成し、以下の内容を記述してください。"
    ```

*   **apply_diff**: 既存のファイルの特定の部分を修正する際に使用します。
    ```markdown
    - 修正する行番号を正確に指定します。
    - 既存のコードと厳密にマッチングするように指示します。
    - 修正前後のコードを明確に示します。
    ```
    ```markdown
    例 1: "src/components/Button.tsx ファイルの 10 行目から 15 行目のコードを、以下のコードに置き換えてください。"
    例 2: "src/App.js ファイルの 20 行目の `console.log('Hello')` を `console.log('World')` に変更してください。"
    例 3: "src/styles/style.css ファイルの `.button` クラスの `background-color` プロパティを `#007bff` に変更してください。"
    ```

### 2.2 検索・分析系ツール

*   **search_files**: コードベース全体を検索する際に使用します。特定のキーワード、コードパターン、または TODO コメントなどを検索できます。
    ```markdown
    - 検索に最適な正規表現を使用するように指示します。
    - 検索対象のファイルパターンを効果的に指定します（例：`*.ts`、`*.js`）。
    - 検索結果のコンテキスト（周辺のコード）を表示するように指示します。
    ```
    ```markdown
    例 1: "src ディレクトリ配下のすべての TypeScript ファイルを検索し、`TODO` コメントをすべて見つけてください。"
    例 2: "src ディレクトリ配下のすべての JavaScript ファイルを検索し、`console.log` を使用している箇所をすべて見つけてください。"
    例 3: "src/components ディレクトリ配下のすべてのファイルで、`Button` コンポーネントが使用されている箇所を検索してください。"
    ```

*   **list_code_definition_names**: コードの構造を把握する際に使用します。ファイル内のクラス、関数、変数などの定義名を一覧表示できます。
    ```markdown
    - モジュール間の依存関係を分析するために使用します。
    - リファクタリングの計画を立案するために使用します。
    - 特定のディレクトリ配下のファイルに限定して定義名を一覧表示することもできます。
    ```
    ```markdown
    例 1: "src/components ディレクトリ配下のすべての TypeScript ファイルの、トップレベルのコード定義名を一覧表示してください。"
    例 2: "src/utils ディレクトリ配下のすべての JavaScript ファイルで定義されている関数名を一覧表示してください。"
    例 3: "このプロジェクトのすべてのファイルで定義されているクラス名を一覧表示してください。"
    ```

## 3. コンテキスト管理の最適化

Roo を効果的に使用するためには、コンテキストを適切に管理することが重要です。

### 3.1 環境情報の活用

Roo は、現在の作業環境に関する様々な情報を提供します。これらの情報を活用することで、より適切な指示を出すことができます。

*   **VSCode Visible Files の確認:** 現在開いているファイルを確認し、関連するファイルへの操作を指示します。
    *   例: "現在開いているファイルは、`src/App.js` と `src/components/Button.tsx` です。Button コンポーネントを修正してください。"
*   **開いているタブの把握:** 現在開いているタブを確認し、関連するファイルへの操作を指示します。
    *   例: "現在、`src/App.js` タブと `src/components/Button.tsx` タブが開いています。Button コンポーネントのスタイルを修正してください。"
*   **現在の作業ディレクトリの理解:** 現在の作業ディレクトリを理解し、ファイルパスの指定などに活用します。
    *   例: "現在の作業ディレクトリは `/Users/me/dev/now/any/we-edit` です。`src/components/Button.tsx` ファイルを修正してください。"
*   **`.clinerules` ファイルの確認:** プロジェクト固有のルールや設定を確認し、それに従って作業を進めます。
    *   例: ".clinerules ファイルに記載されているコーディング規約に従って、コードを記述してください。"

### 3.2 メモリ管理

Roo は、過去の会話履歴を記憶していますが、コンテキストサイズには制限があります。

*   コンテキストサイズを監視し、必要に応じてコンテキストをリフレッシュします。
    *   例: "コンテキストサイズが大きくなってきたので、現在のタスクに関する情報以外は削除してください。"
*   重要情報を優先的に保持し、不要な情報は削除します。
    *   例: "このタスクで重要なのは、Button コンポーネントの修正です。Button コンポーネントに関する情報は保持し、それ以外の情報は削除してください。"
*   タスクが複雑になる場合は、段階的に分割し、各段階でコンテキストを整理します。
    *   例: "まず、Button コンポーネントの UI を修正し、次に、イベントハンドラを実装し、最後に、API との連携を行います。"
*   コンテキストをリフレッシュする際には、`.clinerules` ファイルの内容を再確認し、プロジェクトのルールを再認識します。

## 4. タスク実行の最適化

### 4.1 段階的アプローチ

複雑なタスクを Roo に実行させる場合は、段階的なアプローチを採用することで、より正確で効率的な結果を得ることができます。

1.  **タスク分析:**
    *   目的を明確にします。
        *   例: "Button コンポーネントのスタイルを修正する"
    *   必要なステップを特定します。
        *   例:
            1.  Button コンポーネントのコードを読み込む。
            2.  スタイルを修正する。
            3.  修正後のコードを適用する。
            4.  変更を確認する。
    *   依存関係を把握します。
        *   例: "Button コンポーネントは、`src/components/Button.tsx` ファイルに定義されています。"
2.  **実行計画:**
    *   使用するツールを選択します。
        *   例: `read_file`、`apply_diff`
    *   実行順序を決定します。
        *   例:
            1.  `read_file` で Button コンポーネントのコードを読み込む。
            2.  `apply_diff` でスタイルを修正する。
            3.  変更を確認する。
    *   エラー処理の方法を準備します。
        *   例: エラーが発生した場合は、エラーメッセージを提示し、修正を試みる。
3.  **段階的実行:**
    *   1 ステップずつ実行し、結果を確認します。
        *   例: "まず、`read_file` ツールを使用して、Button コンポーネントのコードを読み込んでください。"
    *   必要に応じて、計画を調整します。
        *   例: 読み込んだコードに問題がある場合は、修正を指示する。

### 4.2 エラー処理とリカバリー

Roo がエラーを発生させた場合、適切なエラー処理とリカバリー戦略を立てることが重要です。

*   エラーメッセージを注意深く解釈し、原因を特定します。
    *   例: "エラーメッセージ「ファイルが見つかりません」は、ファイルパスが間違っていることを示しています。"
*   代替アプローチを準備します。
    *   例: ファイルが見つからない場合は、別のファイルパスを試す。
*   必要に応じて、ユーザーとの効果的なコミュニケーションを行い、追加の情報を求めます。
    *   例: "ファイルパスが間違っている可能性があります。正しいファイルパスを教えてください。"
*   エラーが発生した場合、直前の状態に戻す（ロールバック）ことを検討します。
*   エラーが発生した場合、ログに記録し、後で分析できるようにします。

## 5. コミュニケーションの最適化

### 5.1 プロンプト構造

Roo への指示（プロンプト）は、明確で構造化された形式で記述することが重要です。

```markdown
<task>
具体的な指示
</task>

オプション:
- 優先順位: 高/中/低
- 制約条件: 例: "このコードは、React 18 に対応している必要があります。"
- 期待される出力形式: 例: "JSON 形式で出力してください。"
```

*   `<task>` タグで囲まれた部分に、具体的な指示を記述します。
*   オプションとして、優先順位、制約条件、期待される出力形式などを指定します。
*   プロンプトは、簡潔で明確な表現を使用します。
*   プロンプトは、Roo が理解しやすいように、構造化された形式で記述します。
*   プロンプトは、必要な情報をすべて含めるようにします。
*   プロンプトは、曖昧な表現を避けます。

### 5.2 フィードバックの活用

Roo の回答に対して、積極的にフィードバックを提供することで、より正確で適切な結果を得ることができます。

*   ユーザーの意図を正確に理解しているか確認し、必要に応じて修正を提案します。
    *   例: "Button コンポーネントのスタイルを変更する意図は、ボタンの色を変更することですか？"
*   提案された修正を迅速に適用し、結果を確認します。
    *   例: "提案されたコードを適用しました。結果を確認してください。"
*   継続的な改善プロセスを維持し、Roo のパフォーマンスを向上させます。
    *   例: "この修正はうまくいきました。ありがとうございます。"
*   Roo の回答が不正確な場合は、具体的にどこが間違っているかを指摘します。
*   Roo の回答が不完全な場合は、不足している情報を具体的に伝えます。
*   Roo の回答が分かりにくい場合は、より分かりやすい説明を求めます。

## 6. MCP 操作の最適化

MCP (Model Context Protocol) を使用することで、Roo の機能をさらに拡張できます。

### 6.1 ツール利用

*   **use_mcp_tool**: MCP サーバーが提供するツールを利用します。
    ```markdown
    - 適切なサーバーとツールを選択します。
    - パラメータを正確に指定します。
    - 結果を適切に処理します。
    ```
    ```markdown
    例: "weather-server の get_forecast ツールを使用して、東京の天気予報を取得してください。パラメータは、`city` が `Tokyo`、`days` が `3` です。"
    ```
    *   MCP サーバーのドキュメントを参照し、利用可能なツールとパラメータを確認します。
    *   ツールの入力パラメータの型と形式を正確に指定します。
    *   ツールの実行結果を解析し、必要な情報を抽出します。
    *   ツールの実行結果がエラーの場合は、エラーメッセージを適切に処理します。

### 6.2 リソースアクセス

*   **access_mcp_resource**: MCP サーバーが提供するリソースにアクセスします。
    ```markdown
    - リソース URI を正確に指定します。
    - レスポンスを効果的に活用します。
    ```
    ```markdown
    例: "weather-server の weather://tokyo/current リソースにアクセスして、現在の東京の天気情報を取得してください。"
    ```
    *   MCP サーバーのドキュメントを参照し、利用可能なリソースと URI を確認します。
    *   リソース URI の形式を正確に指定します。
    *   リソースへのアクセス結果を解析し、必要な情報を抽出します。
    *   リソースへのアクセス結果がエラーの場合は、エラーメッセージを適切に処理します。

## 7. プロジェクト固有の最適化

### 7.1 .clinerules の活用

`.clinerules` ファイルには、プロジェクト固有のルールやベストプラクティスが記述されています。

*   プロジェクト固有のルールを理解し、遵守します。
    *   例: ".clinerules ファイルに記載されているコーディング規約に従って、コードを記述してください。"
*   コミットメッセージの規約を遵守します。
    *   例: ".clinerules ファイルに記載されているコミットメッセージの形式に従って、コミットメッセージを記述してください。"
*   文書化要件を遵守します。
    *   例: ".clinerules ファイルに記載されているドキュメントの形式に従って、ドキュメントを記述してください。"
*   `.clinerules` ファイルを定期的に確認し、最新の状態に保ちます。
*   `.clinerules` ファイルに記載されているルールが、現在のプロジェクトに適切かどうかを評価し、必要に応じて修正します。

### 7.2 チーム規約の遵守

チームで定められた規約を遵守することで、コードの品質と可読性を向上させることができます。

*   コーディング規約を遵守します。
    *   例: "このプロジェクトでは、JavaScript のコーディング規約として、ESLint と Prettier を使用しています。これらのツールを使用して、コードのスタイルを統一してください。"
*   コードレビュープロセスを尊重します。
    *   例: "コードをコミットする前に、必ずチームメンバーにコードレビューを依頼してください。"
*   ドキュメント規約を遵守します。
    *   例: "コードの変更に合わせて、ドキュメントを更新してください。"
*   チームのコミュニケーションツール（例：Slack、Microsoft Teams）を活用し、チームメンバーとの連携を密にします。
*   チームの会議に参加し、プロジェクトの進捗状況や課題を共有します。

## 8. パフォーマンス最適化

Roo の応答時間とリソース使用量を最適化することで、より効率的な開発を行うことができます。

### 8.1 応答時間の最適化

*   必要最小限のツール使用を心がけます。
    *   例: 複数のツールを組み合わせるのではなく、1 つのツールで完結できる場合は、そのツールを使用します。
*   効率的なファイル操作を行います。
    *   例: 大規模なファイルを読み込む場合は、必要な部分のみを読み込むようにします。
*   適切なバッチ処理を行います。
    *   例: 複数のファイルを同時に処理する必要がある場合は、バッチ処理を使用します。
*   プロンプトを簡潔にし、AI プロバイダへの送信データ量を削減します。
*   AI プロバイダの応答時間を短縮するために、適切なモデルを選択します。

### 8.2 リソース使用の最適化

*   メモリ使用量を管理します。
    *   例: 不要な変数を削除し、メモリリークを防ぎます。
*   コンテキストサイズを制御します。
    *   例: コンテキストサイズが大きくなりすぎないように、不要な情報を削除します。
*   適切なキャッシュ戦略を検討します。
    *   例: 頻繁にアクセスする情報は、キャッシュに保存します。
*   RooCode の設定を最適化し、リソース使用量を削減します。

## 9. セキュリティ考慮事項

Roo を使用する際には、セキュリティに関する考慮事項も重要です。

### 9.1 機密情報の取り扱い

*   環境変数を適切に使用し、機密情報をコードに直接記述しないようにします。
    *   例: API キーやパスワードなどの機密情報は、環境変数に保存し、コードには直接記述しないようにします。
*   機密ファイルは、`.gitignore` などを使用して、バージョン管理から除外します。
    *   例: データベースの接続情報や API キーを含むファイルは、`.gitignore` に追加して、バージョン管理から除外します。
*   セキュアな通信を確保します。
    *   例: HTTPS を使用して、通信を暗号化します。
*   機密情報が誤って公開されないように、細心の注意を払います。

### 9.2 アクセス制御

*   適切な権限レベルを維持します。
    *   例: Roo がアクセスできるファイルやリソースを制限します。
*   セキュリティ境界を尊重します。
    *   例: Roo がアクセスできる範囲を、必要最小限に制限します。
*   監査ログを維持します。
    *   例: Roo の操作ログを記録し、不正なアクセスや操作を監視します。
*   RooCode のアクセス権限を適切に管理し、不正なアクセスを防ぎます。

## 10. トラブルシューティング

Roo の使用中に問題が発生した場合、以下の手順でトラブルシューティングを行います。

### 10.1 一般的な問題

*   コンテキストの喪失: プロンプトが長すぎる、または複雑すぎる場合に発生することがあります。プロンプトを分割し、コンテキストを整理することで対応します。
    *   例: タスクを複数のステップに分割し、各ステップで Roo に指示を出す。
*   ツールエラー: ツールが正しく動作しない場合は、エラーメッセージを確認し、原因を特定します。
    *   例: エラーメッセージがファイルが見つからないことを示している場合は、ファイルパスを確認する。
*   依存関係の問題: 必要なライブラリがインストールされていない、またはバージョンが古い場合に発生することがあります。依存関係を適切に管理します。
    *   例: `npm install` コマンドを実行して、必要なライブラリをインストールする。
*   AI プロバイダのエラー: AI プロバイダがエラーを返した場合は、エラーメッセージを確認し、原因を特定します。
    *   例: API キーが正しくない場合は、正しい API キーを設定する。

### 10.2 回復戦略

*   バックアップの活用: 変更を適用する前に、必ずバックアップを作成します。
    *   例: Git を使用して、変更をコミットする前に、ブランチを作成する。
*   代替アプローチの適用: 問題が解決しない場合は、別のツールやアプローチを試します。
    *   例: `apply_diff` がうまくいかない場合は、`write_to_file` を使用して、ファイルを完全に書き換える。
*   エスカレーションパスの把握: 問題が解決しない場合は、チームメンバーに相談します。
    *   例: Roo の使用方法について不明な点がある場合は、チームのリーダーに質問する。
*   問題が発生した場合は、再現可能な手順を記録し、後で分析できるようにします。
*   問題が発生した場合は、RooCode のログを確認し、原因を特定します。
*   問題が発生した場合は、RooCode の設定を見直し、問題の原因となる設定がないか確認します。

## 11. RooCode と AI プロバイダ間のやり取り

RooCode は、AI プロバイダ（例：OpenAI、Anthropic）と連携して、様々なタスクを実行します。RooCode は、ユーザーからの指示をプロンプトとして AI プロバイダに送信し、AI プロバイダからの応答を解析して、適切なツールを選択し、実行します。

*   **プロンプトの構造:**
    *   RooCode は、ユーザーからの指示を、AI プロバイダが理解しやすいように、構造化されたプロンプトに変換します。
    *   プロンプトには、タスクの目的、必要な情報、制約条件などが含まれます。
    *   プロンプトは、各モードの特性に合わせて調整されます。
        *   例: Code Mode では、コードの記述や修正に関する指示を明確に記述します。
        *   例: Architect Mode では、設計に関する質問や提案を記述します。
*   **応答の解析:**
    *   AI プロバイダからの応答は、RooCode によって解析され、タスクの実行に必要な情報（例：ツール名、パラメータ）が抽出されます。
    *   応答の解析には、自然言語処理技術が使用されます。
    *   応答がエラーの場合は、エラーメッセージを解析し、適切な対応を行います。
*   **ツールの選択と実行:**
    *   解析された情報に基づいて、RooCode は適切なツールを選択し、実行します。
    *   ツールの選択には、タスクの種類、コンテキスト情報、AI プロバイダからの応答などが考慮されます。
    *   ツールの実行には、CLI コマンドの実行、ファイルの読み書き、MCP 操作などが含まれます。
*   **結果のフィードバック:**
    *   ツールの実行結果は、ユーザーにフィードバックされます。
    *   フィードバックには、実行結果、エラーメッセージ、進捗状況などが含まれます。
    *   ユーザーは、フィードバックに基づいて、次の指示を RooCode に与えます。
*   **プロンプトの例:**
    *   Code Mode:
        ```markdown
        <task>
        TypeScript で、React の Button コンポーネントを実装してください。props として、`label` (string) と `onClick` (function) を受け取り、ボタンをクリックしたときに `onClick` 関数が実行されるようにしてください。
        </task>
        ```
    *   Architect Mode:
        ```markdown
        <task>
        このプロジェクトのディレクトリ構造を分析し、React コンポーネントの再利用性を高めるために、どのように構造を見直すべきか提案してください。
        </task>
        ```
    *   Ask Mode:
        ```markdown
        <task>
        React の Context API の使い方について、具体的なコード例を交えて説明してください。
        </task>
        ```
    *   Debug Mode:
        ```markdown
        <task>
        このエラーメッセージ「TypeError: Cannot read properties of undefined (reading 'map')」の原因を特定し、修正するためのコードを提案してください。
        </task>
        ```
*   **RooCode と AI プロバイダ間のやり取りの最適化:**
    *   プロンプトの精度を高め、AI プロバイダが正確な応答を生成できるようにします。
    *   AI プロバイダからの応答を効率的に解析し、必要な情報を迅速に抽出します。
    *   適切なツールを選択し、タスクを効率的に実行します。
    *   ユーザーに分かりやすいフィードバックを提供し、円滑なコミュニケーションを実現します。