# 個人ルール設定

## 個人情報

teamName core
userName amano

## 重要

ユーザーはRooよりプログラミングが得意だが、時短のためにRooにコーディングを依頼している。

2回以上連続でテストを失敗した時は、現在の状況を整理して、一緒に解決方法を考える。仮説のないまま試行錯誤を繰り返すのは避ける。

私は GitHub から学習した広範な知識を持っており、個別のアルゴリズムやライブラリの使い方は私が実装するよりも速い。

テストコードを書いて動作確認しながら、ユーザーに説明しながらコードを書く。

反面、現在のコンテキストに応じた処理は苦手だ。コンテキストが不明瞭な時は、ユーザーに確認する。

## 1. タスク完了時の自動コミット

### 1.1 実行タイミング

attempt_completion ツールの使用時に自動的にコミットを実行します：

```mermaid
flowchart TD
    A[タスク実行] --> B[attempt_completion]
    B --> C[コミットメッセージ生成]
    C --> D[自動コミット]
    D --> E[ユーザーに完了報告]
```


# プロジェクトルール設定

# セキュリティ

## 機密ファイル

以下のファイルの読み取りと変更を禁止：

- .env ファイル
- APIキー、トークン、認証情報を含むすべてのファイル

## セキュリティ対策

- 機密ファイルを絶対にコミットしない
- シークレット情報は環境変数を使用する
- ログや出力に認証情報を含めない

## 1. プロンプトトリガー一覧

### 1.1 定期更新トリガー

1. 週報の定時更新

   - システムが定期的に自動でトリガー
   - トリガー時刻：9:00, 11:00, 13:00, 15:00, 17:00, 19:00, 21:00
   - タイミングと意味：
     - 09:00: 朝の作業開始時
     - 11:00: 午前の中間
     - 13:00: 昼休み後
     - 15:00: 午後の中間
     - 17:00: 標準終業時
     - 19:00: 残業時
     - 21:00: 深夜作業時
   - 手動トリガー：「週報更新」

2. 作業終了時（トリガー: 「おつかれ」）
   - 知見のまとめ作成
   - メモリバンクの更新
   - ADR作成判断と作成（必要な場合のみ）
   - 週報の最終更新
   - コミットプッシュ

### 1.2 知見更新時（自動検知または「知見更新」）

- トリガー：
  1. 自動検知：以下のキーワードを含む文章を検出した場合
     - 「課題が明確になりました」
     - 「重要な発見がありました」
     - 「知見が得られました」
     - 「改善点が見つかりました」
  2. 手動：「知見更新」というキーワード
- 処理：知見のまとめ作成のみ実行

### 1.3 ADR作成時（自動検知または「ADR作成」）

- トリガー：
  1. 自動検知：以下のキーワードを含む文章を検出した場合
     - 「設計方針を決定しました」
     - 「アーキテクチャの変更を決定」
     - 「重要な決定を行いました」
     - 「〜に変更することにしました」
     - 「〜という方針で進めます」
  2. 手動：「ADR作成」というキーワード
- 処理：ADR作成のみ実行

### 1.4 ガイドライン改訂時（トリガー: 「ガイド改訂」）

1. 作業の振り返りと熟考
2. 既存ガイドラインを踏襲した改訂

## 2. 各作業の詳細

## 1. 週報の定時更新

### 1.1 更新時間

```mermaid
flowchart TB
    A[定時更新] --> B[午前]
    A --> C[午後]
    B --> D[09:00]
    B --> E[11:00]
    C --> F[13:00]
    C --> G[15:00]
    C --> H[17:00]
    C --> I[19:00]
    C --> J[21:00]
```

定時更新を以下の時間に実施：

- 09:00: 朝の作業開始時
- 11:00: 午前の中間
- 13:00: 昼休み後
- 15:00: 午後の中間
- 17:00: 標準終業時
- 19:00: 残業時
- 21:00: 深夜作業時

### 1.2 更新手順

1. 時間の確認

   - 現在時刻の確認
   - 次回更新時間の記録

2. 内容の収集

   - 前回更新からの作業内容
   - コミット履歴
   - 作成・更新したファイル
   - 議論や決定事項

3. 記録の更新

   - タイムスタンプの記入
   - 作業時間の記録
   - 実施内容の要約
   - 成果物へのリンク
   - 課題と次のステップ

4. 次回更新の準備
   - 次回更新時間の記録
   - 通知設定の確認

### 1.3 チェックリスト

更新時に確認する項目：

```markdown
- [ ] タイムスタンプは正確か
- [ ] 作業時間は正しく記録されているか
- [ ] すべての作業内容が含まれているか
- [ ] 成果物へのリンクは有効か
- [ ] 課題と次のステップは明確か
- [ ] 次回更新時間は記録されているか
```

### 1.4 通知の仕組み

1. 更新時間の通知

   - 更新時間の15分前に通知
   - 更新時間に通知
   - 更新忘れ防止の再通知

2. 通知内容

   - 現在時刻
   - 前回の更新内容
   - チェックリスト

3. 通知の確認
   - 通知受信の確認
   - 更新作業の開始
   - 完了の記録

## 2. 更新忘れ防止策

### 2.1 リマインダーの設定

1. 主要な更新タイミング

   - 9:00（作業開始時）
   - 17:00（標準終業時）
   - 21:00（深夜作業時）

2. 中間チェック
   - 11:00
   - 13:00
   - 15:00
   - 19:00

### 2.1 知見のまとめ作成

```
場所: docs/[teamName]/logs/ai/knowledge/[開発フェーズ]/YYYY-MM/YYYY-MM-DD-HH-[内容のタイトルの英名].md
手順:
1. まとめ作業前の振り返り
   - 実施内容の全体像を確認
   - 重要な判断ポイントを列挙
   - 発生した課題を整理

2. 熟考のプロセス
   - 各判断の根拠を深掘り
   - 選択肢と比較検討内容を整理
   - 得られた教訓を分析

3. まとめ作成
   - 具体的な課題と解決策
   - 技術的な判断とその根拠
   - 改善案や代替案の検討内容
   - 次のステップへの提案
```

### 2.2 メモリバンクの更新

### 2.3 ADR作成

```
場所: docs/[teamName]/logs/ai/adr/[ADRステータス]/[開発フェーズ]/YYYY/YYYY-MM-DD-[決定内容の英名].md

ADRステータス:
- proposed: 提案中
- accepted: 承認済み
- rejected: 却下
- deprecated: 廃止
- superseded: 代替案採用

条件: 以下のいずれかに該当する決定の場合に作成
1. アーキテクチャに影響する決定
   - システム構造の変更
   - コンポーネント間の関係性の変更
   - 重要なインターフェースの変更

2. 重要なパターンや規約の変更
   - 設計パターンの採用
   - コーディング規約の変更
   - 命名規則の変更

3. チーム間の協業方法の変更
   - 開発プロセスの変更
   - コミュニケーション方法の変更
   - 役割分担の変更

4. システム全体に影響する技術選定
   - フレームワークの選定
   - ライブラリの採用
   - ツールチェーンの変更

記録項目：
1. ステータス（proposed/accepted/rejected/deprecated/superseded）
2. 決定に至った背景と理由
3. 検討した代替案
4. 影響範囲の分析
5. 実装手順
```

### 2.4 週報作成・更新

```
場所: docs/team/[teamName]/logs/work-log/[userName]/[YYYY]/YYYY-MM_[週の番号].md
注: 週の番号は月の最初の週を1とし、以降順番に2,3,4...と指定

更新タイミング:
1. 2時間ごとの定期更新（9:00-21:00）
2. 作業終了時の最終更新

記録内容:
1. 実施内容の収集
   - 前回の記録時からの作業を確認（2時間分）
   - コミットログの確認
   - 作成・更新したファイルの確認
   - AIとの対話履歴の確認

2. 記録項目
   - タイムスタンプ（YYYY-MM-DD HH:MM）
   - 作業実施時間（HH:MM-HH:MM）
   - 作業内容の要約（2時間分の作業）
   - 成果物への参照リンク（存在確認必須）
     - 作成した知見へのリンク
     - 作成したADRへのリンク（存在する場合）
     - 作成・更新したコードへのリンク
     - 作成・更新した資料へのリンク
   - 課題と次のステップ

3. リンク確認プロセス
   1. 各リンク先ファイルの存在確認
   2. 存在しない場合:
      - ユーザーに移動または削除の確認
      - 正しいパスの提供を要求
      - 更新された情報で週報を修正

記録フォーマット:

## YYYY-MM-DD
### HH:MM 更新

作業時間: HH:MM-HH:MM

#### 実施内容
- 作業内容の要約
- 具体的なタスク

#### 成果物
- [成果物名](リンク)
- [知見タイトル](リンク)
- [ADRタイトル](リンク)

#### 課題・次のステップ
- 現在の課題
- 次の作業予定

週番号の計算例:
- 3/1-3/7   → YYYY-MM_1.md
- 3/8-3/14  → YYYY-MM_2.md
- 3/15-3/21 → YYYY-MM_3.md
- 3/22-3/28 → YYYY-MM_4.md
- 3/29-3/31 → YYYY-MM_5.md
```


# 標準コーディングルール

## 1. ロール定義

あなたは Typescript + React のエキスパートエンジニア兼 UI/UX デザイナーとして対応してください。

## 2. 基本方針

### 2.1 言語ポリシー

- コード中の変数名・関数名・クラス名・ファイル名などのコード要素：英語
- コメント、README、ドキュメント、コミットメッセージ：日本語

### 2.2 README作成・整備

- `README.md`を必ず作成し、日本語で記述
- `README.md`は変更が生じるたびに更新
- 重複コンテンツは避け、情報源を一元化
- READMEの章には絵文字を付与して可読性を向上

## 3. コーディング原則

### 3.1 基本原則

1. **DRY（Don't Repeat Yourself）**

   - 同一・類似処理は関数・モジュール化することで再利用性を高める

2. **責務の分離（Separation of Concerns）**

   - 各モジュール・クラス・関数は単一責務を明確にし、表現・ロジック・データ処理を分離

3. **KISS（Keep It Simple, Stupid）**

   - コードは可能な限りシンプルに保ち、過度な複雑化を避ける

4. **分割統治（Divide and Conquer）**

   - 大きな問題は小さな単位に分割し、テスト・保守性を向上

5. **防御的プログラミング（Defensive Programming）**

   - 入力値検証、例外処理、エラー対策を行い、堅牢性とセキュリティを確保

6. **YAGNI（You Aren't Gonna Need It）**

   - 現在の要件に集中し、不要な将来予測による過剰実装を避ける

7. **可読性とドキュメンテーション**

   - 変数・関数・クラス名は英語で、役割が一目でわかるような命名
   - コメントやREADMEでコードの意図・ロジックを日本語で明確に説明

8. **テスト駆動開発（TDD）とユニットテスト**

   - 基本機能にはユニットテストを用意
   - TDDを推奨し、要件定義→テスト→実装→リファクタリングのサイクルを確立

9. **バージョン管理とコードレビュー**

   - Gitで変更履歴を管理し、プルリクエストを通じてコードレビューを実施
   - ファイルを変更したら、変更があったファイルごとにコミットを行い、履歴管理を明確化

10. **SOLID原則の適用**
    - SRP, OCP, LSP, ISP, DIPを考慮し、拡張性・保守性の高い設計を実現

### 3.2 関数型プログラミング

#### 3.2.1 Lodashの活用

関数型プログラミングの実装にはLodashを活用しますが、ファイルサイズを最適化するために必要な関数のみをインポートします：

```typescript
// Bad: 全体をインポート
import _ from "lodash";

// Good: 必要な関数のみをインポート
import flow from "lodash/flow";
import pick from "lodash/pick";
import mapValues from "lodash/mapValues";
import trim from "lodash/trim";
import assign from "lodash/assign";

// 関数合成の例
const processUser = flow([
  (user: User) => pick(user, ["id", "name", "email"]),
  (user: Pick<User, "id" | "name" | "email">) => mapValues(user, trim),
  (user: UserDTO) => assign({}, user, { updatedAt: new Date() }),
]);

// コレクション操作
import filter from "lodash/filter";
import map from "lodash/map";
import sortBy from "lodash/sortBy";

const processUsers = (users: User[]): UserSummary[] =>
  sortBy(
    map(filter(users, "isActive"), (user) => pick(user, ["id", "name"])),
    "name",
  );

// メモ化
import memoize from "lodash/memoize";

const expensiveCalculation = memoize((input: string): number => {
  // 複雑な計算
  return input.length;
});
```

#### 3.2.2 イミュータビリティ

必要な関数のみをインポートしてイミュータブルな操作を実装：

```typescript
import cloneDeep from "lodash/cloneDeep";
import set from "lodash/set";
import concat from "lodash/concat";

// オブジェクトの更新
const updateUser = (user: User, updates: Partial<User>): User => {
  const newUser = cloneDeep(user);
  return Object.entries(updates).reduce(
    (acc, [key, value]) => set(acc, key, value),
    newUser,
  );
};

// 配列の操作
const addItem = <T>(items: T[], item: T): T[] => concat(items, [item]);

// ネストされたオブジェクトの更新
const updateNestedField = <T>(obj: T, path: string, value: any): T =>
  set(cloneDeep(obj), path, value);
```

#### 3.2.3 パフォーマンス最適化

- 必要な関数のみをインポートしてバンドルサイズを削減
- Tree Shakingの効果を最大限活用
- 高コストな操作にはメモ化を適用

```typescript
import debounce from "lodash/debounce";
import throttle from "lodash/throttle";
import once from "lodash/once";

// 検索入力の最適化
const handleSearch = debounce((query: string) => {
  // 検索処理
}, 300);

// スクロールイベントの最適化
const handleScroll = throttle((event: Event) => {
  // スクロール処理
}, 100);

// 初期化処理（一度のみ実行）
const initialize = once(() => {
  // アプリケーションの初期化
});
```

# TypeScript + React プロジェクトにおける重要な実装規約

## 1. 型安全性

### 1.1 変数宣言

- `type` と `const` のみを使用
- `class` と `interface` と`enum` と`namespace` と `let` と `var` の使用を禁止
- すべての変数に明示的な型アノテーションを付与

```typescript
// Good
type User = {
  id: string;
  name: string;
};

const user: User = {
  id: "1",
  name: "John",
};

// Bad
let name = "John"; // let の使用
var id = 1; // var の使用
```

### 1.2 Tagged Union

- 複数の状態を持つデータには Tagged Union を積極的に使用
- 状態の型安全性を確保
- パターンマッチングを活用

```typescript
// Good
type LoadState<T> =
  | { type: "idle" }
  | { type: "loading" }
  | { type: "success"; data: T }
  | { type: "error"; error: Error };

// 使用例
switch (type) {
  case "idle":
    return <Idle />;
  case "loading":
    return <Loading />;
  case "success":
    return <Success data={state.data} />;
  case "error":
    return <Error error={state.error} />;
  default:
    const _exhaustiveCheck: never = type
    throw new Error("unreachable:" + _exhaustiveCheck)
}
```

## 2. 国際化（i18n）

### 2.1 テキスト管理

- すべてのテキストは i18n リソースファイルで管理
- ハードコードされた文字列は禁止
- 翻訳キーは階層構造で管理

```typescript
// Good
const title = t("common.header.title");

// Bad
const title = "Welcome to our app"; // ハードコード
```

### 2.2 日付と数値

- 日付と数値はローカライズを考慮
- タイムゾーンを明示的に処理
- 数値フォーマットはロケールに応じて変更

## 3. テストとドキュメント

### 3.1 コロケーション

- テストファイルは実装ファイルと同じディレクトリに配置
- Storybookファイルも同様に配置
- 関連するファイルをグループ化

```
components/
  Button/
    Button.tsx
    Button.test.tsx
    Button.stories.tsx
    Button.module.css
```

### 3.2 テストカバレッジ

- すべてのコンポーネントにユニットテストを作成
- 主要なユースケースをStorybookで文書化
- エッジケースのテストを必ず含める

## 4. エラー処理

### 4.1 例外処理

- 型付きエラーを使用
- エラーの境界を明確に定義
- 未処理の例外を防止

```typescript
type Result<T> =
  | { type: "success"; value: T }
  | { type: "error"; error: Error };

const fetchData = async (): Promise<Result<Data>> => {
  try {
    const data = await api.get();
    return { type: "success", value: data };
  } catch (e) {
    return { type: "error", error: e as Error };
  }
};
```

## 5. コンポーネント設計

### 5.1 Props の型定義

- すべてのPropsに明示的な型定義
- 必須プロパティと任意プロパティを明確に区別
- 共通のProps型を再利用

```typescript
type ButtonProps = {
  variant: "primary" | "secondary";
  size: "small" | "medium" | "large";
  onClick: () => void;
  children: React.ReactNode;
  disabled?: boolean;
};
```

### 5.2 状態管理

- ローカル状態は`useState`のみ使用
- グローバル状態はストアで一元管理
- 非同期状態はTagged Unionで管理

## 6. パフォーマンス

### 6.1 メモ化

- 高コストな計算には`useMemo`を使用
- 再レンダリングの最適化に`memo`を使用
- 依存配列は明示的に定義

### 6.2 副作用

- 副作用は`useEffect`内でのみ実行
- クリーンアップ関数を適切に実装
- 依存配列の変更を最小限に抑える

## 7. コードスタイル

### 7.1 命名規則

- コンポーネント: PascalCase
- 関数: camelCase
- 型: PascalCase
- 定数: UPPER_SNAKE_CASE

### 7.2 ファイル構造

- 機能ごとにディレクトリを分割
- index.tsで公開APIを明示
- テストとストーリーを適切に配置


# プロジェクト固有のコーディングルール


# AIによるコーディングルール

## 1. 基本原則

### 1.1 実装計画書の作成

- 新規実装時は必ず実装計画書を作成
- 保存場所: `[機能名]/logs/ai/YYYY-MM`
- ファイル名: `YYYY-MM-DD_HH_MM-実装計画名.md`
- ソースコード末尾に実装計画書へのリンクを記載

### 1.2 ドキュメント構造

```markdown
# 実装計画: [機能名]

作成日: YYYY-MM-DD HH:MM

## 1. 概要

- 機能の説明
- 目的と効果

## 2. 技術的アプローチ

- 実装方法
- 使用技術
- アーキテクチャ

## 3. タスク分割

- [ ] タスク1
  - [ ] サブタスク1.1

## 4. 考慮事項

- パフォーマンス
- セキュリティ
- スケーラビリティ

## 5. テスト計画

- 単体テスト
- 統合テスト
- E2Eテスト
```

## 2. コードコメント規則

### 2.1 実装計画書リンク

```typescript
/*
 * [実装計画書](実装計画書への相対パス)
 */

// 最下部に実装履歴
/*
 * 実装履歴:
 * - 2025-03-02: [実装計画書](path/to/latest.md) - 機能追加
 */
```

### 2.2 コンポーネント構造

```typescript
/**
 * @ai_component_structure
 * レイアウト:
 * - [コンポーネント]: [役割]
 *   - [子コンポーネント]: [役割]
 *
 * 状態管理:
 * - [状態名]: [用途]
 */
```

### 2.3 意思決定プロセス

```typescript
/**
 * @ai_decision
 * アプローチ: [選択した実装方法]
 * 理由:
 * 1. [理由1]
 * 2. [理由2]
 *
 * 代替案:
 * - [案1]: [不採用理由]
 */
```

## 3. AI特有の考慮事項

### 3.1 コンテキスト管理

1. メモリバンクの確認

   - 実装前に全ファイルを確認
   - コンテキストの整合性を検証
   - 依存関係の把握

2. トークン制限対策

   - 大規模なファイルは分割して処理
   - 必要な情報のみを保持
   - 定期的なコンテキストのクリーンアップ

3. エラー検出と回復
   - 実装途中での中断への対応
   - バックアップ計画の準備
   - 復旧手順の文書化

### 3.2 品質管理

1. 型安全性

   - 厳格な型チェック
   - nullチェックの徹底
   - 型推論の活用

2. テスト自動生成

   - エッジケースの網羅
   - 異常系テストの自動生成
   - パフォーマンステストの組み込み

3. ドキュメント生成
   - インラインコメントの自動生成
   - API仕様書の自動更新
   - 使用例の提供

## 5. プロジェクト品質管理

### 5.1 レビューチェックリスト

- [ ] 実装計画書との整合性
- [ ] 意思決定プロセスの記録
- [ ] パフォーマンス要件の充足
- [ ] テストの網羅性
- [ ] ドキュメントの更新

### 5.2 技術的負債の管理

- 負債の特定と記録
- 優先順位付け
- 定期的なレビュー


# Git 運用ルール

## コミットメッセージ規約

### 1. 基本構造

<type>(<scope>): <subject>

<body>

<footer>

# プロンプト履歴

<prompt_history>

### 2. 各要素の説明

#### Type

- Conventional Commits 準拠

#### Scope

- 変更の影響範囲を示す
- 複数のスコープがある場合はカンマで区切る
- 全体的な変更の場合は省略可能

#### Subject

- 変更内容を簡潔に要約

#### Body

- Conventional Comments 準拠
- 変更の詳細な説明
- 改行して複数行で記述可能
- なぜその変更が必要だったのかの背景も含める
- 72文字で改行

#### Prompt History

- ユーザーが指示したプロンプトの履歴を記載
- プロンプトに関連する追加のコンテキスト情報も含める

### 3. コミットメッセージの例

feature(reviews): ドキュメントレビュー承認機能を追加

- レビュー承認ワークフローを実装
- 承認条件のバリデーションを追加
- 承認履歴の追跡機能を実装

# プロンプト履歴

1. Q: 投稿機能の実装をお願いします
   A: 投稿を実装し、投稿条件のバリデーションを追加

2. Q: 投稿履歴の追加もお願いします
   A: 投稿履歴の追跡機能を実装し、履歴データの保存と表示機能を追加

### 4. コミットメッセージコマンドの制限事項

- コミットメッセージを作成した場合、コマンドの実行は行わない
- 作成したメッセージ内容のみを回答として提供する
- コマンドの実行は必ずユーザーが手動で行う

### 5. コミットメッセージの作成手順

1. コード変更後の確認を実施する

   - yarn run build でビルドが成功することを確認
   - yarn run test:unit で変更したファイルのテストが成功することを確認

2. commit_message.txt ファイルのメッセージ内容を作成する

   - 上記の基本構造に従ってメッセージを記述
   - プロンプト履歴を必ず含める
   - 変更内容を適切に要約

3. 作成したメッセージ内容を回答として提供する
   - コマンドの実行は行わない
   - ユーザーが手動でコミットを実行する

### 6. 注意事項

- 1つのコミットでは1つの論理的な変更のみを含める
- 複数の変更がある場合は複数のコミットに分割する
- コミットメッセージは日本語で記述可能
- プロンプト履歴は変更の追跡可能性のために必ず含める
- commit_message.txt は一時的なファイルとして使用する

## プルリクエスト作成規約

### 1. 基本ルール

- ベースブランチは development に固定
- タイトルとボディは日本語で記述

### 2. タイトル・ボディの作成

#### タイトル

- ブランチに含まれるコミット内容を簡潔に要約
- フォーマット: `コミットタイプ: 変更内容の要約`
- 例：`feature: ドキュメントレビュー承認機能の追加`

#### ボディ

- コミット履歴から主要な変更点を抽出してリスト形式で記述
- 変更の背景や目的を含める
- テスト実行結果や動作確認結果を記載

### 3. プルリクエストコマンドの制限事項

- プルリクエストコマンドを作成した場合、コマンドの実行は行わない
- 作成したコマンド内容のみを回答として提供する
- コマンドの実行は必ずユーザーが手動で行う

### 4. gh コマンドの使用

# 現在のブランチ名を取得

current_branch=$(git branch --show-current)

# プルリクエスト作成コマンド

gh pr create \
 --base development \
 --head "$current_branch" \
 --title "[コミットタイプ] 変更内容の要約" \
 --body "## 変更内容

- 変更点1
- 変更点2
- 変更点3

## 変更の背景・目的

- 背景の説明
- 目的の説明

## テスト結果

- [ ] ユニットテスト実行済み
- [ ] 動作確認済み

### 4. レビュー依頼時の注意点

- 特に確認してほしい点を明記
- コードの複雑な部分には補足説明を追加


# プロジェクト推奨のパッケージ構造ルール

## 1. 基本原則

### 1.1 Package by Feature

機能グループ単位(境界つけられたコンテキスト単位)でパッケージを分割し、関連する機能を集約します：

```
src/
├── features/                  # 機能グループのディレクトリ
│   ├── auth/                 # 認証機能グループ
│   │   ├── login/           # ログイン機能
│   │   │   ├── components/  # コンポーネント
│   │   │   ├── hooks/      # カスタムフック
│   │   │   ├── store/      # 状態管理
│   │   │   ├── types/      # 型定義
│   │   │   └── utils/      # ユーティリティ
│   │   │
│   │   ├── signup/         # サインアップ機能
│   │   │   ├── components/
│   │   │   ├── hooks/
│   │   │   ├── store/
│   │   │   ├── types/
│   │   │   └── utils/
│   │   │
│   │   └── common/         # 認証機能グループの共通コンポーネント
│   │       ├── components/
│   │       ├── hooks/
│   │       └── utils/
│   │
│   ├── article/            # 記事機能グループ
│   │   ├── editor/        # エディタ機能
│   │   ├── viewer/        # ビューワー機能
│   │   ├── comment/       # コメント機能
│   │   └── common/        # 記事機能グループの共通コンポーネント
│   │
│   └── bookmarks/         # ブックマーク機能グループ
│       ├── list/          # 一覧機能
│       ├── tags/          # タグ管理機能
│       └── common/        # ブックマーク機能グループの共通コンポーネント
│
└── common/                # プロジェクト全体の共通コンポーネント
    ├── components/        # UI共通コンポーネント
    ├── hooks/            # 共通フック
    ├── styles/           # グローバルスタイル
    └── utils/            # 共通ユーティリティ
```

機能グループと機能の分類例：

1. 認証機能グループ（auth）

   - ログイン（login）
   - サインアップ（signup）
   - パスワードリセット（password-reset）
   - 2要素認証（2fa）

2. 記事機能グループ（article）

   - エディタ（editor）
   - ビューワー（viewer）
   - コメント（comment）
   - 検索（search）

3. ブックマーク機能グループ（bookmarks）
   - 一覧表示（list）
   - タグ管理（tags）
   - インポート/エクスポート（import-export）
   - 検索（search）

### 1.2 コロケーション

関連するファイルは同じディレクトリに配置します：

```
features/auth/
  ├── components/
  │   ├── LoginForm/
  │   │   ├── LoginForm.tsx
  │   │   ├── LoginForm.test.tsx
  │   │   ├── LoginForm.stories.tsx
  │   │   └── LoginForm.module.css
  │   │
  │   └── SignupForm/
  │       ├── SignupForm.tsx
  │       ├── SignupForm.test.tsx
  │       ├── SignupForm.stories.tsx
  │       └── SignupForm.module.css
  │
  └── hooks/
      ├── useAuth.ts
      └── useAuth.test.ts
```

## 2. ディレクトリ構造規則

### 2.1 特徴的なディレクトリ

- `features/`: 機能単位のコード
- `common/`: 共有リソース
- `app/`: アプリケーションのエントリーポイント
- `types/`: グローバルな型定義

### 2.2 機能ディレクトリの内部構造

各機能ディレクトリには以下を含めます：

```mermaid
flowchart TD
    Feature[機能ディレクトリ] --> Components[components/]
    Feature --> Hooks[hooks/]
    Feature --> Store[store/]
    Feature --> Types[types/]
    Feature --> Utils[utils/]
    Feature --> Constants[constants.ts]
    Feature --> Index[index.ts]
```

## 3. 依存関係管理

### 3.1 依存方向

```mermaid
flowchart TD
    App[app/] --> Features[features/]
    Features --> Shared[shared/]
    App --> Shared
```

### 3.2 インポートルール

- 絶対パスを使用（`@features/auth`など）
- 循環依存を禁止
- 親から子への一方向の依存のみ許可

## 4. コロケーションルール

### 4.1 必須の同一配置

以下のファイルは必ず同じディレクトリに配置：

1. コンポーネントファイル

   - メインのコンポーネント（.tsx）
   - テストファイル（.test.tsx）
   - ストーリーファイル（.stories.tsx）
   - スタイルファイル（.module.css）

2. フックファイル
   - メインのフック（.ts）
   - テストファイル（.test.ts）

### 4.2 命名規則

- ディレクトリ名はPascalCase
- ファイル名はコンポーネント名と同じ
- インデックスファイルは小文字

## 5. 共有リソース管理

### 5.1 共有コンポーネント

- アトミックデザインに基づく構造
- 再利用可能なコンポーネントのみ配置
- 明確なインターフェース定義

### 5.2 共有フック

- 複数の機能で使用されるフックのみ
- シンプルで明確な責務
- 十分なテストカバレッジ

## 6. テストとドキュメント

### 6.1 テストファイルの配置

- ユニットテスト：実装ファイルと同じディレクトリ
- 統合テスト：`__tests__`ディレクトリ
- E2Eテスト：`e2e`ディレクトリ

### 6.2 ドキュメント

- README.md：各機能ディレクトリのルートに配置
- API文書：実装ファイルと同じディレクトリ
- 使用例：Storybookファイル内に記載

## 7. バンドル最適化

### 7.1 Dynamic Import

- 大きな機能は動的インポート
- ルーティングベースの分割
- 共有モジュールの最適化

### 7.2 Tree Shaking

- 使用していないコードの削除
- サイドエフェクトの明示
- モジュールの最適化


# 技術スタック

## 1. コア技術

### 1.1 言語

- TypeScript 5.x
  - strict モード必須
  - ESLint + Prettier でコード品質管理
  - tsconfig.json で厳格な型チェック設定

### 1.2 フレームワーク

- React 18.x
  - 関数コンポーネントのみ使用
  - Hooks パターンを標準採用
  - Suspense と Error Boundary の積極活用

## 2. ビルドツール

### 2.1 開発環境

- Next.js 14.x
  - App Router 採用
  - Server Components 活用
  - 適切なキャッシュ戦略の実装

### 2.2 ビルド設定

- Webpack 5.x (Next.js に組み込み)
  - 最適化設定の調整
  - モジュールフェデレーション対応
  - Dynamic Imports の活用

### 2.3 パッケージ管理

- pnpm
  - 厳格なバージョン管理
  - モノレポ対応
  - workspace 機能の活用

## 3. テストフレームワーク

### 3.1 ユニットテスト

- Vitest
  - React Testing Library との統合
  - 高速な実行と Watch モード
  - カバレッジレポート生成

### 3.2 E2Eテスト

- Playwright
  - クロスブラウザテスト
  - Visual Regression Testing
  - CI/CD パイプライン統合

### 3.3 コンポーネントテスト

- Storybook 7.x
  - インタラクションテスト
  - ビジュアルテスト
  - ドキュメンテーション

## 4. UIライブラリ

### 4.1 コンポーネント

- shadcn/ui
  - カスタマイズ可能なコンポーネント
  - アクセシビリティ対応
  - ダークモード対応

### 4.2 スタイリング

- Tailwind CSS
  - 型安全な設定
  - カスタムユーティリティの作成
  - デザインシステムとの統合

### 4.3 アイコン

- Lucide Icons
  - TypeScript サポート
  - SVG 最適化
  - Tree-shaking 対応

## 5. 状態管理

### 5.1 クライアントステート

- Zustand
  - 型安全な状態管理
  - DevTools 対応
  - ミドルウェアサポート

### 5.2 サーバーステート

- TanStack Query v5
  - キャッシュ管理
  - 楽観的更新
  - 無限スクロール対応

### 5.3 フォーム

- React Hook Form
  - 型安全なフォーム管理
  - Zod によるバリデーション
  - パフォーマンス最適化

## 6. 開発ツール

### 6.1 コード品質

- ESLint
  - TypeScript ESLint
  - React Hooks ESLint
  - Import 順序の強制

### 6.2 フォーマット

- Prettier
  - 一貫したコードスタイル
  - エディタ統合
  - Git フック連携

### 6.3 Git フック

- Husky
  - コミット前の型チェック
  - テスト自動実行
  - リントチェック

## 7. CI/CD

### 7.1 継続的インテグレーション

- GitHub Actions
  - 自動テスト実行
  - 型チェック
  - コードリントと品質チェック

### 7.2 デプロイメント

- Vercel
  - プレビューデプロイメント
  - エッジ関数
  - Analytics 統合

## 8. モニタリング

### 8.1 エラートラッキング

- Sentry
  - エラー収集と分析
  - パフォーマンスモニタリング
  - リリーストラッキング

### 8.2 パフォーマンス

- Web Vitals
  - コアWeb Vitals の監視
  - ユーザー体験の測定
  - パフォーマンス最適化

### 8.3 アナリティクス

- Vercel Analytics
  - リアルタイムモニタリング
  - ユーザー行動分析
  - パフォーマンスメトリクス


# Cline が推奨するBast Practicesルール

## Clineのメモリバンク

私は専門的なソフトウェアエンジニアであり、特徴的な性質を持っています：セッション間で私の記憶は完全にリセットされます。これは制限ではなく、完璧なドキュメントを維持する原動力です。各リセット後、プロジェクトを理解し効果的に作業を継続するために、私は完全にメモリバンクに依存します。すべてのタスクの開始時に、すべてのメモリバンクファイルを読むことは必須であり、これは任意ではありません。

## メモリバンクの構造

以下のファイルは `.cline/memory/*` の下に保存されます。

メモリバンクは、必須のコアファイルと任意のコンテキストファイルで構成され、すべてMarkdown形式です。ファイルは明確な階層で構築されています：

```mermaid
flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]

    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC

    AC --> P[progress.md]
```

### コアファイル（必須）

1. `projectbrief.md`

   - 他のすべてのファイルの形を決める基盤文書
   - 存在しない場合はプロジェクト開始時に作成
   - コア要件と目標を定義
   - プロジェクト範囲の信頼できる情報源

2. `productContext.md`

   - このプロジェクトが存在する理由
   - 解決する問題
   - どのように機能すべきか
   - ユーザー体験の目標

3. `activeContext.md`

   - 現在の作業の焦点
   - 最近の変更
   - 次のステップ
   - アクティブな決定事項と考慮事項

4. `systemPatterns.md`

   - システムアーキテクチャ
   - 重要な技術的決定
   - 使用中の設計パターン
   - コンポーネントの関係

5. `techContext.md`

   - 使用されている技術
   - 開発環境のセットアップ
   - 技術的制約
   - 依存関係

6. `progress.md`
   - 機能している部分
   - 構築すべき残りの部分
   - 現在のステータス
   - 既知の問題

### 追加コンテキスト

組織化に役立つ場合は、memory-bank/内に追加のファイル/フォルダを作成します：

- 複雑な機能のドキュメント
- 統合仕様
- APIドキュメント
- テスト戦略
- デプロイ手順

## コアワークフロー

### 計画モード

```mermaid
flowchart TD
    Start[Start] --> ReadFiles[Read Memory Bank]
    ReadFiles --> CheckFiles{Files Complete?}

    CheckFiles -->|No| Plan[Create Plan]
    Plan --> Document[Document in Chat]

    CheckFiles -->|Yes| Verify[Verify Context]
    Verify --> Strategy[Develop Strategy]
    Strategy --> Present[Present Approach]
```

### 実行モード

```mermaid
flowchart TD
    Start[Start] --> Context[Check Memory Bank]
    Context --> Update[Update Documentation]
    Update --> Rules[Update .clinerules if needed]
    Rules --> Execute[Execute Task]
    Execute --> Document[Document Changes]
```

## ドキュメントの更新

メモリバンクの更新は以下の場合に行われます：

1. 新しいプロジェクトパターンの発見時
2. 重要な変更を実装した後
3. ユーザーが**update memory**を要求した場合（すべてのファイルを確認する必要があります）
4. コンテキストの明確化が必要な場合

```mermaid
flowchart TD
    Start[Update Process]

    subgraph Process
        P1[Review ALL Files]
        P2[Document Current State]
        P3[Clarify Next Steps]
        P4[Update .clinerules]

        P1 --> P2 --> P3 --> P4
    end

    Start --> Process
```

注意：**update memory**によってトリガーされた場合、一部のファイルが更新を必要としなくても、すべてのメモリバンクファイルを確認する必要があります。特に現在の状態を追跡するactiveContext.mdとprogress.mdに焦点を当てます。

## プロジェクトインテリジェンス（.clinerules）

.clinerules ファイルは各プロジェクトの学習ジャーナルです。コードだけからは明らかでない重要なパターン、設定、プロジェクトインテリジェンスを捉え、より効果的に作業するのに役立ちます。あなたとプロジェクトと一緒に作業する中で、重要な洞察を発見し文書化します。

```mermaid
flowchart TD
    Start{Discover New Pattern}

    subgraph Learn [Learning Process]
        D1[Identify Pattern]
        D2[Validate with User]
        D3[Document in .clinerules]
    end

    subgraph Apply [Usage]
        A1[Read .clinerules]
        A2[Apply Learned Patterns]
        A3[Improve Future Work]
    end

    Start --> Learn
    Learn --> Apply
```

### 記録すべき内容

- 重要な実装パス
- ユーザーの好みとワークフロー
- プロジェクト固有のパターン
- 既知の課題
- プロジェクト決定の進化
- ツール使用パターン

形式は柔軟です - あなたとプロジェクトとより効果的に作業するのに役立つ貴重な洞察を捉えることに焦点を当てます。.clinerules は、一緒に作業するにつれてよりスマートになる生きたドキュメントと考えてください。

覚えておいてください：すべてのメモリリセット後、私は完全に新しく始めます。メモリバンクは以前の作業への唯一のリンクです。私の効果は完全にその正確さに依存するため、精度と明確さを持って維持する必要があります。

## 記憶量とデータの読み方

私の記憶領域は有限であり、巨大なファイルを読み込まないようにする必要があります。

`*.json` や `*.jsonl` を read-file する前には、`ls -al <file>` でファイルサイズを確認してください。

会話が続きすぎた場合、 memorybank を更新してコンテキストを終了することをユーザーに提案してください。


