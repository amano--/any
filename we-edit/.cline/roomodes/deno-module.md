---
name: Deno:Module
groups:
  - read
  - edit
  - browser
  - command
  - mcp
source: "project"
---

## 実装モード: モジュールモード

モジュールモードはディレクトリの下で複数のファイルで構成される。

例

```
xxx/
  mod.ts    - 外部向けのエクスポート（re-export のみ）
  deps.ts   - 他のモジュールの mod.ts を import し、モジュール内で使用する機能を re-export
  lib.ts    - 実装（deps.ts からの import を使用）
  types.ts  - 型定義
  mod.test.ts
  lib.test.ts
yyy/
  mod.ts    - 外部向けのエクスポート（re-export のみ）
  deps.ts   - 他のモジュールの mod.ts を import し、モジュール内で使用する機能を re-export
  lib.ts    - 実装（deps.ts からの import を使用）
  types.ts  - 型定義
  mod.test.ts
  lib.test.ts
```

モジュールをテストする時は、 `deno test -A <module-name>/*.test.ts` で実行する。

テストが落ちた時は、次の手順を踏む。

機能追加の場合

1. 機能追加の場合、まず `deno test -A` で全体のテストが通過しているかを確認する
2. 修正後、対象のスクリプト or モジュールをテストする

修正の場合

1. `deno test -A <module-name>/**.test.ts` でモジュールのテストを実行する
2. 落ちたモジュールのテストを確認し、実装を参照する。
  - テストは一つずつ実行する `deno test -A <module-name>/foo.test.ts`
3. 落ちた理由をステップバイステップで考える(闇雲に修正しない!)
3. 実装を修正する。必要な場合、実行時の過程を確認するためのプリントデバッグを挿入する。
4. モジュールのテスト実行結果を確認
  - 修正出来た場合、プリントデバッグを削除する
  - 集できない場合、3 に戻る。
5. モジュール以外の全体テストを確認

テストが落ちた場合、落ちたテストを修正するまで次のモジュールに進まない。

### モジュールファイルの役割とコンテキスト境界

モジュールのコンテキスト（文脈）は、mod.ts と deps.ts の2つのファイルによって完全に定義される：

- mod.ts: モジュールのパブリックインターフェース
  - 外側に向けて実装を export する
  - 他のモジュールでは、ここ以外から直接 import することを禁止する
  - re-export のみを行い、実装を含まない
  - このファイルを見るだけで、モジュールが提供する機能を理解できる

- deps.ts: モジュールの依存関係定義
  - 他のモジュールの mod.ts を import する
  - モジュール内で使用する機能を re-export する
  - 外部依存をここで一元管理する
  - このファイルを見るだけで、モジュールの依存関係を理解できる

その他のファイル：

- types.ts: モジュール内の型定義を集約する
- lib.ts: 実装を担当
  - コード量が少ない(150行未満)とき、 lib.ts の下で実装してもよい
  - 量が多い時は複数のファイルに分割する
  - 実装内では deps.ts からの import を使用する
  - モジュール外からは直接参照されない
- *.test.ts: テストファイル
  - 実装ファイルと同じディレクトリに配置する
  - 実装ファイルと1:1で対応するテストファイルを作成する

この構造により：
- モジュールの依存関係が透明になる
- コードの変更影響範囲が予測しやすくなる
- モジュール間の結合度を低く保てる
- リファクタリングが容易になる

モジュールモードではスクリプトモードと違って、ライブラリの参照に `jsr:` や `npm:` を推奨しない。モジュールを参照する場合、 `deno add jsr:@david/dax@0.42.0` のようにして、 `deno.json` に依存を追加する。

```ts
// OK
import $ from "@david/dax";

// NG
import $ from "jsr:@david/dax@0.42.0";